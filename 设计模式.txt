创建型模式：抽象了实例化过程
一，abstract factory:抽象工厂模式
1，用途：
   提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们的具体类
2，适用：
   一个系统要独立于它的产品的创建、组合和表示时；一个系统要由多个产品系列中的一个来配置时；当你要强调一系列相关的产品对象的设计以便进行联合使用时；当你提供一个产品类库，而只想显示它们的接口而不是实现时
3，参与者：
AbstractFactory:声明一个创建抽象产品对象的操作接口
ConcreteFactory:实现创建具体产品对象的操作
AbstractProduct:为一类产品对象声明一个接口
ConcreteProduct:定义一个将被相应的具体工厂创建的具体对象；实现AbstractProduct接口
Client:仅使用由AbstractFactory和AbstractProduct类声明的接口
4，优缺点：
它分离了具体的类；它使得易于交，实现产品的一致性；难以支持新种类产品
5，实现：
  1) 将工厂作为单件：一个应用中一般每个产品系列只需要一个ConcreteFactory实例，因此工厂最好实现为一个单例(Singleton)
  2) 创建产品：AbstractFactory仅声明一个创建产品的接口，真正的产品创建是ConcreteProduct子类实现的。通常做法是为每个产品定义一个工厂方法(Factory Method)，一个具体的工厂将为每个产品重定义该工厂方法以指定产品。这样就要求每个产品系列都要有一个新的具体工厂子类，即使产品差别小。
6，相关模式：AbstractFactory类通常用工厂方法(FactoryMethod)实现，也可用Prototype实现，而具体的工厂多是一个单件(Singleton)
二，builder:生成器模式
1,作用：将一个复杂对象的构建与表示分离，使得同样的构建过程可创建不同的表示
2，适用性：
   当创建复杂对象的算法应该独立于该对象的组成部分及它们的装配方式时
   当构造过程必须允许被构造的对象有不同的表示时
3，参与者：
   Builder:为创建一个Product对象的各个部件指定抽象接口
   ConcreteBuilder:实现Builder的接口及构造和装配该产品的各个部件；定义并明确它所创建的表示；提供一个检索产品的接口
   Director:构造一个使用Builder接口的对象
   Product:表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程；包含定义组成部件的类，包括这些部件装配成最终产品的接口
三，factory method(工厂方法)---对象创建型模式
1，意图：定义一个用于创建对象的接口，让子类决定实例化哪一个类，这使得一个类的实例化延迟到其子类
2，适用性：
    当一个类不知道它所必须创建的对象的类的时候
    当一个类希望由它的子类来指定它所创建的对象的时候
    当类创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候
参与者：
    Product----定义工厂方法所创建的对象的接口
    ConcreteProduct-----实现Product的接口
    Creator-------声明工厂方法，该方法返回一个Product对象。也可以定义一个工厂方法的缺省实现，返回一个缺省的ConcreteProduct;可以调用工厂方法以创建一个Product对象
    ConcreteCreator-----重定义工厂方法以返回一个ConcreteProduct实例
四，prototype(原型)----对象创建型模式
1，意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
2，适用性：
   当一个系统应独立于它的产品创建、构成和表示时，要使用原型模式
   当要实例化的类是在运行时刻指定时，例如通过动态装载；或者
   为了避免创建一个与产品类层次平行的工厂类层次时；或者
   当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些
3，参与者
   Prototype:声明一个克隆自身的接口
   ConcretePrototype:实现一个克隆自身的操作
   Client:让一个原型克隆自身从而创建一个新的对象
五，singleton(单件)-----对象创建型模式
1，意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。可以通过让类自身负责保存它的唯一实例，这个类可以保证没有其他实例可以被创建(通过截取创建新对象的请求)，并且它可以提供一个访问该实例的方法。
2，适用性：
   当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。
   当这个唯一实例应该是通过子类实例化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。
3，参与者：
   Singleton:定义一个instance操作，允许客户访问它的唯一实例。instance是一个类操作；可能负责创建它自己的唯一实例。

创建型模式总结

用一个系统创建的那些对象的类对系统进行参数化有两种方法：一种是生成创建对象的类的子类；这对应于Factory Method模式，其缺点是仅为了改变产品类，就可能需要创建一个新的子类，这样的改变可能是级联的，如产品的创建者是由一个工厂方法创建，那么必须重定义它的创建者。另一种对系统进行参数化的方法更多依赖于对象复合：定义一个对象负责明确产品对象的类，并将它作为该系统的参数。这是Abstract Factory,Builder,Prototype模式的关键特征。都涉及创建一个新的负责创建产品对象的工厂对象，抽象工厂由这个工厂产生多个类的对象，Builder由这个工厂对象使用一个相对复杂的协议，逐步创建一个复杂产品；prototype由该工厂对象通过拷贝原型对象来创建产品对象。在这种情况下，因原型返回产品对象，所以工厂对象和原型对象是同一对象。
设计原则是从工厂方法模式开始，考虑到灵活性，可以向其他模式演变。
------------------------
结构型模式：采用继承机制来组合接口或实现
一，adapter(适配器)模式-------类对象结构型模式
1，意图：将一个类的接口转换为客户希望的另一个接口，解决接口不兼容问题
2，适用性：
     使用一个已经存在的类，而其接口不符合要求
     创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作
     使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配他们的接口，对象适配器可以适配它的父类接口
3，参与者                                                                  Target:定义client使用的与特定领域相关的接口
   Client:与符合Target接口的对象协同
   Adaptee:定义一个已经存在的接口，这个接口需要适配
   Adapter:对Adaptee与Target接口进行适配
二，bridge(桥接)-------------对象型结构模式
1，意图：将抽象部分与它的实现部分分离，使它们都可以独立变化
2，